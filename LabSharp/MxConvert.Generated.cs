/*
 * Lab# - Matlab interaction library for .Net
 * 
 * Copyright (C) 2005 Julien Roncaglia
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

/*
 * THIS CODE IS GENERATED BY MxConvert.xsl FROM MxConvert.xml, 
 * DO NOT EDIT DIRECTLY.
 */
using System;
using System.Collections.Generic;
using System.Text;

namespace LabSharp
{
    public static partial class MxConvert
    {
        const string ONE_ELEMENT_REQUIRED = "A mxArray with only 1 element is required.";
        const string NO_WAY_TO_CAST = "Cannot cast a {0} mxArray to {1}.";
        const string NO_DOTNET_TYPE = "No corresponding .Net type exists for {0}.";

        /// <summary>
        /// Convert a mxArray to the corresponding type of array.
        /// </summary>
        /// <remarks>
        /// No conversion of type occurs, if the ClassID is Single, a float[] will be
        /// returned and never a double[].
        /// </remarks>
        static Array _ConvertToArray(MxArray array, ClassID classId, int ndims)
        {
            switch (classId)
            {
                
                case ClassID.Char:
                    return _ToCharArray(array);             

                case ClassID.Logical:
                    return _ToBooleanArray(array);             

                case ClassID.Int8:
                    return _ToSByteArray(array);             

                case ClassID.UInt8:
                    return _ToByteArray(array);             

                case ClassID.UInt16:
                    return _ToUInt16Array(array);             

                case ClassID.Int16:
                    return _ToInt16Array(array);             

                case ClassID.UInt32:
                    return _ToUInt32Array(array);             

                case ClassID.Int32:
                    return _ToInt32Array(array);             

                case ClassID.UInt64:
                    return _ToUInt64Array(array);             

                case ClassID.Int64:
                    return _ToInt64Array(array);             

                case ClassID.Single:
                    return _ToSingleArray(array);             

                case ClassID.Double:
                    return _ToDoubleArray(array);             

                default:
                    throw new InvalidCastException(string.Format(NO_DOTNET_TYPE, classId));
            }
        }

        /// <summary>
        /// Convert a mxArray to the corresponding basic object (Not an array).
        /// </summary>
        /// <remarks>
        /// No conversion of type occurs, if the ClassID is Single, a float will be
        /// returned and never a double.
        /// </remarks>        
        static Object _ConvertToBasicType(MxArray array, ClassID classId)
        {
            switch(classId)
            {
                
                case ClassID.Char:
                    if (array.IsComplex)
                    {
                        return _ToChar_Cplx(array);
                    }
                    else
                    {
                        return _ToChar(array);
                    }

                case ClassID.Logical:
                    if (array.IsComplex)
                    {
                        return _ToBoolean_Cplx(array);
                    }
                    else
                    {
                        return _ToBoolean(array);
                    }

                case ClassID.Int8:
                    if (array.IsComplex)
                    {
                        return _ToSByte_Cplx(array);
                    }
                    else
                    {
                        return _ToSByte(array);
                    }

                case ClassID.UInt8:
                    if (array.IsComplex)
                    {
                        return _ToByte_Cplx(array);
                    }
                    else
                    {
                        return _ToByte(array);
                    }

                case ClassID.UInt16:
                    if (array.IsComplex)
                    {
                        return _ToUInt16_Cplx(array);
                    }
                    else
                    {
                        return _ToUInt16(array);
                    }

                case ClassID.Int16:
                    if (array.IsComplex)
                    {
                        return _ToInt16_Cplx(array);
                    }
                    else
                    {
                        return _ToInt16(array);
                    }

                case ClassID.UInt32:
                    if (array.IsComplex)
                    {
                        return _ToUInt32_Cplx(array);
                    }
                    else
                    {
                        return _ToUInt32(array);
                    }

                case ClassID.Int32:
                    if (array.IsComplex)
                    {
                        return _ToInt32_Cplx(array);
                    }
                    else
                    {
                        return _ToInt32(array);
                    }

                case ClassID.UInt64:
                    if (array.IsComplex)
                    {
                        return _ToUInt64_Cplx(array);
                    }
                    else
                    {
                        return _ToUInt64(array);
                    }

                case ClassID.Int64:
                    if (array.IsComplex)
                    {
                        return _ToInt64_Cplx(array);
                    }
                    else
                    {
                        return _ToInt64(array);
                    }

                case ClassID.Single:
                    if (array.IsComplex)
                    {
                        return _ToSingle_Cplx(array);
                    }
                    else
                    {
                        return _ToSingle(array);
                    }

                case ClassID.Double:
                    if (array.IsComplex)
                    {
                        return _ToDouble_Cplx(array);
                    }
                    else
                    {
                        return _ToDouble(array);
                    }

                default:
                    throw new InvalidCastException(string.Format(NO_DOTNET_TYPE, classId));
            }
        }

        /// <summary>
        /// Try to convert a mxArray a specified .Net type.
        /// </summary>
        /// <remarks>
        /// <para>
        ///     A conversion could occurs, if you ask for a double[,] but the content is
        ///     a 2 dimensions mxArray of Single it will be converted to a double[,].
        /// </para>
        /// </remarks>        
        /// <param name="noVectorization">
        /// If this parametter is true and the user ask for a 1D array an exception will 
        /// be thrown if the mxArray isn't of dimension 1, otherwise it will vectorize the array.
        /// </param>
        static TType _ConvertToSomeType<TType>(MxArray array, ClassID classId, int ndims, bool noVectorization)
        {
            Type genericType = typeof(TType);
            // There is two sorts of Array types : the ones that answer true to IsArray, where we could
            // get dimensions, element type and other details; and the Array class that could contain
            // any array.
            bool isArray = genericType.IsArray;
            bool isComplex = array.IsComplex;
            Type arrayElementType = genericType.GetElementType();

            
    if (genericType == typeof(char))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToChar_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToChar(array);
        }
    }
    else if(arrayElementType == typeof(char))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToCharArray1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToCharArray(array);
        }
    }
    else

    if (genericType == typeof(bool))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToBoolean_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToBoolean(array);
        }
    }
    else if(arrayElementType == typeof(bool))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToBooleanArray1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToBooleanArray(array);
        }
    }
    else

    if (genericType == typeof(sbyte))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToSByte_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToSByte(array);
        }
    }
    else if(arrayElementType == typeof(sbyte))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToSByteArray1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToSByteArray(array);
        }
    }
    else

    if (genericType == typeof(byte))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToByte_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToByte(array);
        }
    }
    else if(arrayElementType == typeof(byte))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToByteArray1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToByteArray(array);
        }
    }
    else

    if (genericType == typeof(ushort))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToUInt16_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToUInt16(array);
        }
    }
    else if(arrayElementType == typeof(ushort))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToUInt16Array1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToUInt16Array(array);
        }
    }
    else

    if (genericType == typeof(short))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToInt16_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToInt16(array);
        }
    }
    else if(arrayElementType == typeof(short))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToInt16Array1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToInt16Array(array);
        }
    }
    else

    if (genericType == typeof(uint))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToUInt32_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToUInt32(array);
        }
    }
    else if(arrayElementType == typeof(uint))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToUInt32Array1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToUInt32Array(array);
        }
    }
    else

    if (genericType == typeof(int))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToInt32_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToInt32(array);
        }
    }
    else if(arrayElementType == typeof(int))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToInt32Array1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToInt32Array(array);
        }
    }
    else

    if (genericType == typeof(ulong))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToUInt64_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToUInt64(array);
        }
    }
    else if(arrayElementType == typeof(ulong))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToUInt64Array1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToUInt64Array(array);
        }
    }
    else

    if (genericType == typeof(long))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToInt64_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToInt64(array);
        }
    }
    else if(arrayElementType == typeof(long))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToInt64Array1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToInt64Array(array);
        }
    }
    else

    if (genericType == typeof(float))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToSingle_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToSingle(array);
        }
    }
    else if(arrayElementType == typeof(float))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToSingleArray1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToSingleArray(array);
        }
    }
    else

    if (genericType == typeof(double))
    {
        // If the user want to convert to a single element
        if (isComplex)
        {
            return (TType)(Object)_ToDouble_Cplx(array);
        }
        else
        {
            return (TType)(Object)_ToDouble(array);
        }
    }
    else if(arrayElementType == typeof(double))
    {
        // If the user want to convert to an array of this element
        int rank = genericType.GetArrayRank();

        if ( (rank == 1) && (!noVectorization) )
        {
            return (TType)(Object)_ToDoubleArray1D(array);
        }
        else
        {
            if (rank != ndims)
            {
                throw new InvalidCastException(string.Format(
                    "The mxArray have {0} dimensions but the result have {1}, no way to convert", ndims, rank));
            }
            return (TType)(Object)_ToDoubleArray(array);
        }
    }
    else

                throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, typeof(TType).Name));
        }

        
        #region Convert to Char
        
        public unsafe static char _ToChar(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.Char :
                {
                    char* pr;
                    pr = (char*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "char"));
            }
        }

        public unsafe static Complex<char> _ToChar_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.Char :
                {
                    char* pr, pi;
                    pr = (char*)array.RealElements;
                    pi = (char*)array.ImaginaryElements;
                    Complex<char> result;
                    
                    result = new Complex<char>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<char>"));
            }
        }

        public unsafe static char[] _ToCharArray1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                char[] result = new char[count];
                
            switch(classId)
            {
                
                case ClassID.Char :
                {
                    char* p;
                    p = (char*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "char"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToCharArray(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<char>), dims);
                switch(classId)
                {
                    
                case ClassID.Char :
                {
                    char* pr, pi;
                    pr = (char*)array.RealElements;
                    pi = (char*)array.ImaginaryElements;
                    Complex<char> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<char>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<char>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(char), dims);
                switch(classId)
                {
                    
                case ClassID.Char :
                {
                    char* p;
                    p = (char*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "char"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Boolean
        
        public unsafe static bool _ToBoolean(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.Logical :
                {
                    bool* pr;
                    pr = (bool*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "bool"));
            }
        }

        public unsafe static Complex<bool> _ToBoolean_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.Logical :
                {
                    bool* pr, pi;
                    pr = (bool*)array.RealElements;
                    pi = (bool*)array.ImaginaryElements;
                    Complex<bool> result;
                    
                    result = new Complex<bool>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<bool>"));
            }
        }

        public unsafe static bool[] _ToBooleanArray1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                bool[] result = new bool[count];
                
            switch(classId)
            {
                
                case ClassID.Logical :
                {
                    bool* p;
                    p = (bool*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "bool"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToBooleanArray(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<bool>), dims);
                switch(classId)
                {
                    
                case ClassID.Logical :
                {
                    bool* pr, pi;
                    pr = (bool*)array.RealElements;
                    pi = (bool*)array.ImaginaryElements;
                    Complex<bool> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<bool>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<bool>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(bool), dims);
                switch(classId)
                {
                    
                case ClassID.Logical :
                {
                    bool* p;
                    p = (bool*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "bool"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to SByte
        
        public unsafe static sbyte _ToSByte(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "sbyte"));
            }
        }

        public unsafe static Complex<sbyte> _ToSByte_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<sbyte> result;
                    
                    result = new Complex<sbyte>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<sbyte>"));
            }
        }

        public unsafe static sbyte[] _ToSByteArray1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                sbyte[] result = new sbyte[count];
                
            switch(classId)
            {
                
                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "sbyte"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToSByteArray(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<sbyte>), dims);
                switch(classId)
                {
                    
                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<sbyte> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<sbyte>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<sbyte>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(sbyte), dims);
                switch(classId)
                {
                    
                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "sbyte"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Byte
        
        public unsafe static byte _ToByte(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "byte"));
            }
        }

        public unsafe static Complex<byte> _ToByte_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<byte> result;
                    
                    result = new Complex<byte>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<byte>"));
            }
        }

        public unsafe static byte[] _ToByteArray1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                byte[] result = new byte[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "byte"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToByteArray(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<byte>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<byte> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<byte>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<byte>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(byte), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "byte"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to UInt16
        
        public unsafe static ushort _ToUInt16(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (ushort)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (ushort)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "ushort"));
            }
        }

        public unsafe static Complex<ushort> _ToUInt16_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<ushort> result;
                    
                    result = new Complex<ushort>(
                        (ushort)(*pr),
                        (ushort)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<ushort> result;
                    
                    result = new Complex<ushort>(
                        (ushort)(*pr),
                        (ushort)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<ushort> result;
                    
                    result = new Complex<ushort>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<ushort>"));
            }
        }

        public unsafe static ushort[] _ToUInt16Array1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                ushort[] result = new ushort[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ushort)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ushort)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "ushort"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToUInt16Array(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<ushort>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<ushort> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ushort>(
                            (ushort)(*pr++),
                            (ushort)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<ushort> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ushort>(
                            (ushort)(*pr++),
                            (ushort)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<ushort> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ushort>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<ushort>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(ushort), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ushort)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ushort)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "ushort"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Int16
        
        public unsafe static short _ToInt16(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (short)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (short)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "short"));
            }
        }

        public unsafe static Complex<short> _ToInt16_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<short> result;
                    
                    result = new Complex<short>(
                        (short)(*pr),
                        (short)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<short> result;
                    
                    result = new Complex<short>(
                        (short)(*pr),
                        (short)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<short> result;
                    
                    result = new Complex<short>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<short>"));
            }
        }

        public unsafe static short[] _ToInt16Array1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                short[] result = new short[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (short)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (short)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "short"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToInt16Array(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<short>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<short> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<short>(
                            (short)(*pr++),
                            (short)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<short> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<short>(
                            (short)(*pr++),
                            (short)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<short> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<short>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<short>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(short), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((short)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((short)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "short"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to UInt32
        
        public unsafe static uint _ToUInt32(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (uint)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (uint)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return (uint)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return (uint)(*pr);
                    
                }

                case ClassID.UInt32 :
                {
                    uint* pr;
                    pr = (uint*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "uint"));
            }
        }

        public unsafe static Complex<uint> _ToUInt32_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<uint> result;
                    
                    result = new Complex<uint>(
                        (uint)(*pr),
                        (uint)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<uint> result;
                    
                    result = new Complex<uint>(
                        (uint)(*pr),
                        (uint)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<uint> result;
                    
                    result = new Complex<uint>(
                        (uint)(*pr),
                        (uint)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<uint> result;
                    
                    result = new Complex<uint>(
                        (uint)(*pr),
                        (uint)(*pi));
                    
                    return result;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<uint> result;
                    
                    result = new Complex<uint>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<uint>"));
            }
        }

        public unsafe static uint[] _ToUInt32Array1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                uint[] result = new uint[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (uint)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (uint)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (uint)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (uint)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "uint"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToUInt32Array(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<uint>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<uint> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<uint>(
                            (uint)(*pr++),
                            (uint)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<uint> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<uint>(
                            (uint)(*pr++),
                            (uint)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<uint> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<uint>(
                            (uint)(*pr++),
                            (uint)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<uint> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<uint>(
                            (uint)(*pr++),
                            (uint)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<uint> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<uint>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<uint>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(uint), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((uint)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((uint)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((uint)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((uint)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "uint"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Int32
        
        public unsafe static int _ToInt32(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (int)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (int)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return (int)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return (int)(*pr);
                    
                }

                case ClassID.Int32 :
                {
                    int* pr;
                    pr = (int*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "int"));
            }
        }

        public unsafe static Complex<int> _ToInt32_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<int> result;
                    
                    result = new Complex<int>(
                        (int)(*pr),
                        (int)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<int> result;
                    
                    result = new Complex<int>(
                        (int)(*pr),
                        (int)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<int> result;
                    
                    result = new Complex<int>(
                        (int)(*pr),
                        (int)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<int> result;
                    
                    result = new Complex<int>(
                        (int)(*pr),
                        (int)(*pi));
                    
                    return result;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<int> result;
                    
                    result = new Complex<int>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<int>"));
            }
        }

        public unsafe static int[] _ToInt32Array1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                int[] result = new int[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (int)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (int)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (int)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (int)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "int"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToInt32Array(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<int>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<int> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<int>(
                            (int)(*pr++),
                            (int)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<int> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<int>(
                            (int)(*pr++),
                            (int)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<int> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<int>(
                            (int)(*pr++),
                            (int)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<int> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<int>(
                            (int)(*pr++),
                            (int)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<int> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<int>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<int>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(int), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((int)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((int)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((int)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((int)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "int"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to UInt64
        
        public unsafe static ulong _ToUInt64(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (ulong)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (ulong)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return (ulong)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return (ulong)(*pr);
                    
                }

                case ClassID.UInt32 :
                {
                    uint* pr;
                    pr = (uint*)array.RealElements;                
                    
                    return (ulong)(*pr);
                    
                }

                case ClassID.Int32 :
                {
                    int* pr;
                    pr = (int*)array.RealElements;                
                    
                    return (ulong)(*pr);
                    
                }

                case ClassID.UInt64 :
                {
                    ulong* pr;
                    pr = (ulong*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "ulong"));
            }
        }

        public unsafe static Complex<ulong> _ToUInt64_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(
                        (ulong)(*pr),
                        (ulong)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(
                        (ulong)(*pr),
                        (ulong)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(
                        (ulong)(*pr),
                        (ulong)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(
                        (ulong)(*pr),
                        (ulong)(*pi));
                    
                    return result;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(
                        (ulong)(*pr),
                        (ulong)(*pi));
                    
                    return result;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(
                        (ulong)(*pr),
                        (ulong)(*pi));
                    
                    return result;
                }

                case ClassID.UInt64 :
                {
                    ulong* pr, pi;
                    pr = (ulong*)array.RealElements;
                    pi = (ulong*)array.ImaginaryElements;
                    Complex<ulong> result;
                    
                    result = new Complex<ulong>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<ulong>"));
            }
        }

        public unsafe static ulong[] _ToUInt64Array1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                ulong[] result = new ulong[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ulong)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ulong)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ulong)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ulong)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ulong)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (ulong)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* p;
                    p = (ulong*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "ulong"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToUInt64Array(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<ulong>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(
                            (ulong)(*pr++),
                            (ulong)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(
                            (ulong)(*pr++),
                            (ulong)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(
                            (ulong)(*pr++),
                            (ulong)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(
                            (ulong)(*pr++),
                            (ulong)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(
                            (ulong)(*pr++),
                            (ulong)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(
                            (ulong)(*pr++),
                            (ulong)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* pr, pi;
                    pr = (ulong*)array.RealElements;
                    pi = (ulong*)array.ImaginaryElements;
                    Complex<ulong> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<ulong>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<ulong>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(ulong), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ulong)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ulong)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ulong)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ulong)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ulong)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((ulong)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* p;
                    p = (ulong*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "ulong"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Int64
        
        public unsafe static long _ToInt64(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (long)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (long)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return (long)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return (long)(*pr);
                    
                }

                case ClassID.UInt32 :
                {
                    uint* pr;
                    pr = (uint*)array.RealElements;                
                    
                    return (long)(*pr);
                    
                }

                case ClassID.Int32 :
                {
                    int* pr;
                    pr = (int*)array.RealElements;                
                    
                    return (long)(*pr);
                    
                }

                case ClassID.Int64 :
                {
                    long* pr;
                    pr = (long*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "long"));
            }
        }

        public unsafe static Complex<long> _ToInt64_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(
                        (long)(*pr),
                        (long)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(
                        (long)(*pr),
                        (long)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(
                        (long)(*pr),
                        (long)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(
                        (long)(*pr),
                        (long)(*pi));
                    
                    return result;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(
                        (long)(*pr),
                        (long)(*pi));
                    
                    return result;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(
                        (long)(*pr),
                        (long)(*pi));
                    
                    return result;
                }

                case ClassID.Int64 :
                {
                    long* pr, pi;
                    pr = (long*)array.RealElements;
                    pi = (long*)array.ImaginaryElements;
                    Complex<long> result;
                    
                    result = new Complex<long>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<long>"));
            }
        }

        public unsafe static long[] _ToInt64Array1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                long[] result = new long[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (long)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (long)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (long)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (long)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (long)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (long)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* p;
                    p = (long*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "long"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToInt64Array(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<long>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(
                            (long)(*pr++),
                            (long)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(
                            (long)(*pr++),
                            (long)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(
                            (long)(*pr++),
                            (long)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(
                            (long)(*pr++),
                            (long)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(
                            (long)(*pr++),
                            (long)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(
                            (long)(*pr++),
                            (long)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* pr, pi;
                    pr = (long*)array.RealElements;
                    pi = (long*)array.ImaginaryElements;
                    Complex<long> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<long>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<long>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(long), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((long)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((long)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((long)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((long)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((long)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((long)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* p;
                    p = (long*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "long"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Single
        
        public unsafe static float _ToSingle(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.UInt32 :
                {
                    uint* pr;
                    pr = (uint*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.Int32 :
                {
                    int* pr;
                    pr = (int*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.UInt64 :
                {
                    ulong* pr;
                    pr = (ulong*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.Int64 :
                {
                    long* pr;
                    pr = (long*)array.RealElements;                
                    
                    return (float)(*pr);
                    
                }

                case ClassID.Single :
                {
                    float* pr;
                    pr = (float*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "float"));
            }
        }

        public unsafe static Complex<float> _ToSingle_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.UInt64 :
                {
                    ulong* pr, pi;
                    pr = (ulong*)array.RealElements;
                    pi = (ulong*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.Int64 :
                {
                    long* pr, pi;
                    pr = (long*)array.RealElements;
                    pi = (long*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(
                        (float)(*pr),
                        (float)(*pi));
                    
                    return result;
                }

                case ClassID.Single :
                {
                    float* pr, pi;
                    pr = (float*)array.RealElements;
                    pi = (float*)array.ImaginaryElements;
                    Complex<float> result;
                    
                    result = new Complex<float>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<float>"));
            }
        }

        public unsafe static float[] _ToSingleArray1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                float[] result = new float[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* p;
                    p = (ulong*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* p;
                    p = (long*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (float)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Single :
                {
                    float* p;
                    p = (float*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "float"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToSingleArray(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<float>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* pr, pi;
                    pr = (ulong*)array.RealElements;
                    pi = (ulong*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* pr, pi;
                    pr = (long*)array.RealElements;
                    pi = (long*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(
                            (float)(*pr++),
                            (float)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Single :
                {
                    float* pr, pi;
                    pr = (float*)array.RealElements;
                    pi = (float*)array.ImaginaryElements;
                    Complex<float> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<float>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<float>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(float), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* p;
                    p = (ulong*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* p;
                    p = (long*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((float)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Single :
                {
                    float* p;
                    p = (float*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "float"));
                }
            }
            
            return result;
        }
        
        #endregion

        #region Convert to Double
        
        public unsafe static double _ToDouble(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr;
                    pr = (byte*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.Int8 :
                {
                    sbyte* pr;
                    pr = (sbyte*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.UInt16 :
                {
                    ushort* pr;
                    pr = (ushort*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.Int16 :
                {
                    short* pr;
                    pr = (short*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.UInt32 :
                {
                    uint* pr;
                    pr = (uint*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.Int32 :
                {
                    int* pr;
                    pr = (int*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.UInt64 :
                {
                    ulong* pr;
                    pr = (ulong*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.Int64 :
                {
                    long* pr;
                    pr = (long*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.Single :
                {
                    float* pr;
                    pr = (float*)array.RealElements;                
                    
                    return (double)(*pr);
                    
                }

                case ClassID.Double :
                {
                    double* pr;
                    pr = (double*)array.RealElements;                
                    
                    return *pr;
                    
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId, "double"));
            }
        }

        public unsafe static Complex<double> _ToDouble_Cplx(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            if (array.NumberOfElements != 1)
                throw new InvalidCastException(ONE_ELEMENT_REQUIRED);
            ClassID classId = array.Class;
            bool isComplex = array.IsComplex;   
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.UInt64 :
                {
                    ulong* pr, pi;
                    pr = (ulong*)array.RealElements;
                    pi = (ulong*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.Int64 :
                {
                    long* pr, pi;
                    pr = (long*)array.RealElements;
                    pi = (long*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.Single :
                {
                    float* pr, pi;
                    pr = (float*)array.RealElements;
                    pi = (float*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(
                        (double)(*pr),
                        (double)(*pi));
                    
                    return result;
                }

                case ClassID.Double :
                {
                    double* pr, pi;
                    pr = (double*)array.RealElements;
                    pi = (double*)array.ImaginaryElements;
                    Complex<double> result;
                    
                    result = new Complex<double>(*pr, *pi);
                    
                    return result;
                }

                default:
                    throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                        "Complex<double>"));
            }
        }

        public unsafe static double[] _ToDoubleArray1D(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            ClassID classId = array.Class;
                double[] result = new double[count];
                
            switch(classId)
            {
                
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* p;
                    p = (ulong*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* p;
                    p = (long*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Single :
                {
                    float* p;
                    p = (float*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = (double)(*p++);
                        
                    }
                    break;
                }

                case ClassID.Double :
                {
                    double* p;
                    p = (double*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        
                        result[i] = *p++;
                        
                    }
                    break;
                }

                default:
                    throw new InvalidCastException(string.Format(NO_WAY_TO_CAST, classId, "double"));
            }
            
            return result;
        }
        
        public unsafe static Array _ToDoubleArray(MxArray array)
        {
            if (array == null) throw new ArgumentNullException("array");
            int count = array.NumberOfElements;
            int[] dims = array.Dimensions;
            Array result;
            ClassID classId = array.Class;
                
            int[] coords;

            if (array.IsComplex)
            {
                result = Array.CreateInstance(typeof(Complex<double>), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* pr, pi;
                    pr = (byte*)array.RealElements;
                    pi = (byte*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* pr, pi;
                    pr = (sbyte*)array.RealElements;
                    pi = (sbyte*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* pr, pi;
                    pr = (ushort*)array.RealElements;
                    pi = (ushort*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* pr, pi;
                    pr = (short*)array.RealElements;
                    pi = (short*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* pr, pi;
                    pr = (uint*)array.RealElements;
                    pi = (uint*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* pr, pi;
                    pr = (int*)array.RealElements;
                    pi = (int*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* pr, pi;
                    pr = (ulong*)array.RealElements;
                    pi = (ulong*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* pr, pi;
                    pr = (long*)array.RealElements;
                    pi = (long*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Single :
                {
                    float* pr, pi;
                    pr = (float*)array.RealElements;
                    pi = (float*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(
                            (double)(*pr++),
                            (double)(*pi++));
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                case ClassID.Double :
                {
                    double* pr, pi;
                    pr = (double*)array.RealElements;
                    pi = (double*)array.ImaginaryElements;
                    Complex<double> element;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        element = new Complex<double>(*pr++, *pi++);
                        
                        result.SetValue(element, coords);
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "Complex<double>"));
                }                
            }
            else
            {
                result = Array.CreateInstance(typeof(double), dims);
                switch(classId)
                {
                    
                case ClassID.UInt8 :
                {
                    byte* p;
                    p = (byte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int8 :
                {
                    sbyte* p;
                    p = (sbyte*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt16 :
                {
                    ushort* p;
                    p = (ushort*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int16 :
                {
                    short* p;
                    p = (short*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt32 :
                {
                    uint* p;
                    p = (uint*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int32 :
                {
                    int* p;
                    p = (int*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.UInt64 :
                {
                    ulong* p;
                    p = (ulong*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Int64 :
                {
                    long* p;
                    p = (long*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Single :
                {
                    float* p;
                    p = (float*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue((double)(*p++), coords);
                        
                    }
                    break;
                }

                case ClassID.Double :
                {
                    double* p;
                    p = (double*)array.RealElements;
                    for(int i = 0 ; i < count; i++)
                    {
                        //TODO: Optimize the coordinate table generation by not re-calculating it every time.
                        coords = MxUtils.CoordinatesFromIndex(i, dims);
                        
                        result.SetValue(*p++, coords);
                        
                    }
                    break;
                }

                    default:
                        throw new Exception(string.Format(NO_WAY_TO_CAST, classId,
                            "double"));
                }
            }
            
            return result;
        }
        
        #endregion


        static Object _ToDotNetType(MxArray array, ClassID classId, int ndims)
        {
             Object result = null;
             switch(classId)
             {
                 
                 case ClassID.Char :
                     if (ndims == 1)
                     {
                         result = _ToChar(array);
                     }
                     else
                     {
                         result = _ToCharArray(array);
                     }
                     break;

                 case ClassID.Logical :
                     if (ndims == 1)
                     {
                         result = _ToBoolean(array);
                     }
                     else
                     {
                         result = _ToBooleanArray(array);
                     }
                     break;

                 case ClassID.Int8 :
                     if (ndims == 1)
                     {
                         result = _ToSByte(array);
                     }
                     else
                     {
                         result = _ToSByteArray(array);
                     }
                     break;

                 case ClassID.UInt8 :
                     if (ndims == 1)
                     {
                         result = _ToByte(array);
                     }
                     else
                     {
                         result = _ToByteArray(array);
                     }
                     break;

                 case ClassID.UInt16 :
                     if (ndims == 1)
                     {
                         result = _ToUInt16(array);
                     }
                     else
                     {
                         result = _ToUInt16Array(array);
                     }
                     break;

                 case ClassID.Int16 :
                     if (ndims == 1)
                     {
                         result = _ToInt16(array);
                     }
                     else
                     {
                         result = _ToInt16Array(array);
                     }
                     break;

                 case ClassID.UInt32 :
                     if (ndims == 1)
                     {
                         result = _ToUInt32(array);
                     }
                     else
                     {
                         result = _ToUInt32Array(array);
                     }
                     break;

                 case ClassID.Int32 :
                     if (ndims == 1)
                     {
                         result = _ToInt32(array);
                     }
                     else
                     {
                         result = _ToInt32Array(array);
                     }
                     break;

                 case ClassID.UInt64 :
                     if (ndims == 1)
                     {
                         result = _ToUInt64(array);
                     }
                     else
                     {
                         result = _ToUInt64Array(array);
                     }
                     break;

                 case ClassID.Int64 :
                     if (ndims == 1)
                     {
                         result = _ToInt64(array);
                     }
                     else
                     {
                         result = _ToInt64Array(array);
                     }
                     break;

                 case ClassID.Single :
                     if (ndims == 1)
                     {
                         result = _ToSingle(array);
                     }
                     else
                     {
                         result = _ToSingleArray(array);
                     }
                     break;

                 case ClassID.Double :
                     if (ndims == 1)
                     {
                         result = _ToDouble(array);
                     }
                     else
                     {
                         result = _ToDoubleArray(array);
                     }
                     break;

             }
             return result;
        }       
    }
}
